# 完美数问题与自动机问题
## 完美数问题
### 2020/11/15
***
近日有朋友问了我一道C语言编程题，题目如下：

一个数如果恰好等于它的因子之和，这个数就称为“完（美）数”。例如，6的（真）因子为1，2，3，而又有6=1+2+3，因此6是“完（美）数”。请编程序找出1000之内的所有完（美）数。

大家可以试着做一下，这个其实难度不大，只要你想明白了就不难。

其实因为我太菜，我一开始就这样去码代码：
```
#include <stdio.h>

int main() {
    int sum = 0;
    for (int i = 1; i <= 1000; ++i)
    {
        for (int j = 1; j < i; ++j)
        {
            if (i % j == 0)
            {
                i /= j;
                sum += j;
            }
        }
        if (sum == i) printf("%5d",i);
    }
    return 0;
}
```
于是后来发现怎么也没法正常运行（死循环......），想了一下，认为i这里如果在内层嵌套循环中的值发生了改变，就有许多数都被跳过了，而且i还是1的时候内层循环就无法终止，于是又想了一下，用k来做中间变量并对其他地方做了一下改动以避免发生刚才的事。
```
#include <stdio.h>

int main() {
    int sum = 1;
    for (int i = 2; i <= 1000; ++i)
    {
        for (int j = 2, k = i; j < k; ++j)
        {
            if (i % j == 0)
            {
                k /= j;
                sum += j;
            }
        }
        if (sum == i) printf("%5d",i);
    }
    return 0;
}
```
然后，我才反应过来，我搞复杂了。。。。试问：有什么必要去做除法嘛？？？于是我果断改成了这个代码，或许有待优化，但总比之前的好多了！
```
#include <stdio.h>

int main() {
    int sum = 1;
    for (int i = 2; i <= 1000; ++i)
    {
        for (int j = 2; j < i; ++j)
        {
            if (i % j == 0)
            {
                sum += j;
            }
        }
        if (sum == i) printf("%5d",i);
    }
    return 0;
}
```
然后又出了bug......这回直接没有输出？！我去检查一遍结果没有任何收获，最后没招，动用了“杀手锏”——Debug！调试过后才发现，换下一个数的时候sum没做任何更新，当然不能正常运行，于是最终版本出世~
```
#include <stdio.h>

int main() {
    int sum = 1;
    for (int i = 2; i <= 1000; ++i)
    {
        for (int j = 2; j < i; ++j)
        {
            if (i % j == 0)
            {
                sum += j;
            }
        }
        if (sum == i) printf("%5d",i);
        sum = 1;
    }
    return 0;
}
```
各位能陪我闹到最后，我真的很感谢！这个是在简单不过的一个小程序，实际上没什么必要去写，但是这个我一是以分享心情的目的，二是以友好交流为目的来写，希望各位大佬不吝赐教！
***
***
## 自动机问题
### 2020/11/15
***
古人有云：“温故而知新，可以为师矣。”
复习真的很重要！最近老师的实训作业有一道题就是计数单词个数问题，刚开始我还一直在想如何去实现？后来发现自己想到的方案都是不可行的，漏洞多多。后来我就猛然想起，教材上确实有这个例子，但是忘了是什么样，只依稀记得大致思路是这样：当它读到一个空格时，如果下一个字符不是空格，它就会在计数器上加一。于是我硬凭着自己的构想码代码，结果失败......
实在没办法，我只好去翻翻教材（**P136 例5.9 单词计数问题——单词计数和有穷自动机的使用**），为了防止再次忘记，我特意做了这个~复习~笔记。


**注：使用isspace函数时要引用头文件ctype.h，否则不被识别为有效函数！**


```
#include <ctype.h>
enum{ IN , OUT };

//以上是前期准备，要知道这些并不是在下面这段代码所在的函数里~

if (isspace(c))
{
    if (state == IN)
    {
        state = OUT;
    }
    else
    {
        state = OUT;
    }
}
else
{
    if (state == IN)
    {
        state = IN;
    }
    else
    {
        state = IN;
        ++count;
    }
}
```
以上是最原始的自动机代码，显然可以看到这个东西做了很多冗余的操作，但其实问题不大，因为我们还可以化简哒~
```
if (isspace(c))
    state = OUT;
else if (state == OUT){
    state = IN;
    ++count;
}
```
这样就显得简洁多了~
不过自动机并不是只能用这一种实现方式，下面还有另外一种实现方式：
```
//本例是以单词计数为例
while (c != EOF){
    while ((c = getchar()) != EOF && isspace(c));
    if (c == EOF) break;
    ++count;
    while ((c = getchar()) != EOF && !isspace(c));
}
```
当然，自动机内容远不止这些，日后要学的还多着哩！
就先记到这里吧，日后如果对自动机有了更深一层的理解，我还会来更新一下的！
***